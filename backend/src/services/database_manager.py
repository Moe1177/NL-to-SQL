import os
import sqlite3
from typing import Any, Dict, List

import pandas as pd


class DatabaseManager:
    """Manages SQLite database operations using pandas and sqlite3"""

    def __init__(self, db_path: str = "data.db"):
        self.db_path = db_path
        self._ensure_database_exists()

    def _ensure_database_exists(self):
        """Create database file if it doesn't exist"""
        if not os.path.exists(self.db_path):
            # Create empty database
            conn = sqlite3.connect(self.db_path)
            conn.close()

    def create_table_from_dataframe(self, df: pd.DataFrame, table_name: str):
        """
        Create SQLite table from pandas DataFrame.

        Args:
            df: pandas DataFrame containing the data
            table_name: Name for the SQL table
        """
        conn = sqlite3.connect(self.db_path)
        try:
            # Use pandas to_sql method to create table
            df.to_sql(table_name, conn, if_exists="replace", index=False)
        finally:
            conn.close()

    def execute_query(self, sql_query: str, table_name: str) -> Dict[str, Any]:
        """
        Execute SQL query and return results.

        Args:
            sql_query: SQL query string generated by LLM
            table_name: Name of the table to query

        Returns:
            Dict containing query results, columns, and metadata
        """
        print(f"Executing query for table: {table_name}")  # Debug log
        print(f"Query: {sql_query}")  # Debug log
        
        if not table_name:
            raise ValueError("Table name cannot be empty")
            
        conn = sqlite3.connect(self.db_path)
        try:
            # Verify the table exists
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?", (table_name,))
            if not cursor.fetchone():
                raise ValueError(f"Table '{table_name}' does not exist")

            # Execute query using pandas for easy result handling
            df_result = pd.read_sql_query(sql_query, conn)

            results = {
                "data": df_result.to_dict("records"),
                "columns": list(df_result.columns),
                "row_count": len(df_result),
            }

            print(f"Query executed successfully. Returned {len(df_result)} rows.")  # Debug log
            return results

        except sqlite3.Error as e:
            print(f"SQLite error while executing query: {str(e)}")  # Debug log
            raise ValueError(f"Database error: {str(e)}")
        except Exception as e:
            print(f"Unexpected error while executing query: {str(e)}")  # Debug log
            raise ValueError(f"Error executing query: {str(e)}")
        finally:
            conn.close()

    def get_table_context(self, table_name: str) -> Dict[str, Any]:
        """
        Get table context for RAG (column info, sample data, etc.).
        This provides context to the LLM for better SQL generation.

        Args:
            table_name: Name of the table

        Returns:
            Dict containing table schema and sample data for RAG context
        """
        print(f"Getting context for table: {table_name}")  # Debug log
        
        if not table_name:
            raise ValueError("Table name cannot be empty")
            
        conn = sqlite3.connect(self.db_path)
        
        try:
            # First verify the table exists
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?", (table_name,))
            if not cursor.fetchone():
                raise ValueError(f"Table '{table_name}' does not exist")
            
            # Get table schema information
            # Escape table name by wrapping in quotes
            cursor.execute(f'PRAGMA table_info("{table_name}")')
            print(f"Retrieved schema for table: {table_name}")  # Debug log
            
            columns_info = cursor.fetchall()
            if not columns_info:
                raise ValueError(f"No columns found in table '{table_name}'")
            
            # Format column information
            columns = []
            for col_info in columns_info:
                columns.append(
                    {
                        "name": col_info[1],
                        "type": col_info[2],
                        "nullable": not col_info[3],
                    }
                )

            # Get sample data (first few rows for context)
            # Escape table name by wrapping in quotes
            sample_df = pd.read_sql_query(
                f'SELECT * FROM "{table_name}" LIMIT 3',
                conn
            )
            sample_data = sample_df.to_dict("records")

            # Get row count
            # Escape table name by wrapping in quotes
            cursor.execute(f'SELECT COUNT(*) FROM "{table_name}"')
            row_count = cursor.fetchone()[0]

            context = {
                "table_name": table_name,
                "columns": columns,
                "sample_data": sample_data,
                "row_count": row_count,
                "column_names": [col["name"] for col in columns],
            }

            print(f"Successfully retrieved context for table: {table_name}")  # Debug log
            return context

        except sqlite3.Error as e:
            print(f"SQLite error while getting table context: {str(e)}")  # Debug log
            raise ValueError(f"Database error: {str(e)}")
        except Exception as e:
            print(f"Unexpected error while getting table context: {str(e)}")  # Debug log
            raise ValueError(f"Error getting table context: {str(e)}")
        finally:
            conn.close()

    def list_tables(self) -> List[str]:
        """List all tables in the database"""
        conn = sqlite3.connect(self.db_path)
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
            tables = [row[0] for row in cursor.fetchall()]
            return tables
        finally:
            conn.close()

    def delete_table(self, table_name: str):
        """Delete a table from the database"""
        conn = sqlite3.connect(self.db_path)
        try:
            cursor = conn.cursor()
            cursor.execute(f"DROP TABLE IF EXISTS {table_name}")
            conn.commit()
        finally:
            conn.close()

    def get_table_info(self, table_name: str) -> Dict[str, Any]:
        """
        Get detailed information about a specific table.

        TODO: Expand this method to include:
        - Column statistics and distributions
        - Data quality metrics
        - Index information
        - Table relationships
        """
        return self.get_table_context(table_name)
