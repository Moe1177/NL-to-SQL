import os
import sqlite3
from typing import Any, Dict, List

import pandas as pd


class DatabaseManager:
    """Manages SQLite database operations using pandas and sqlite3"""

    def __init__(self, db_path: str = "data.db"):
        self.db_path = db_path
        self._ensure_database_exists()

    def _ensure_database_exists(self):
        """Create database file if it doesn't exist"""
        if not os.path.exists(self.db_path):
            # Create empty database
            conn = sqlite3.connect(self.db_path)
            conn.close()

    def create_table_from_dataframe(self, df: pd.DataFrame, table_name: str):
        """
        Create SQLite table from pandas DataFrame.

        Args:
            df: pandas DataFrame containing the data
            table_name: Name for the SQL table
        """
        conn = sqlite3.connect(self.db_path)
        try:
            # Use pandas to_sql method to create table
            df.to_sql(table_name, conn, if_exists="replace", index=False)
        finally:
            conn.close()

    def execute_query(self, sql_query: str, table_name: str) -> Dict[str, Any]:
        """
        Execute SQL query and return results.

        Args:
            sql_query: SQL query string generated by LLM
            table_name: Name of the table to query

        Returns:
            Dict containing query results, columns, and metadata

        TODO: Add your custom logic here for:
        - SQL query validation and sanitization
        - Query performance optimization
        - Result formatting and pagination
        - Error handling for complex queries
        """
        conn = sqlite3.connect(self.db_path)
        try:
            # TODO: Add SQL query validation here
            # You should validate that:
            # - Query only contains SELECT statements (no INSERT/UPDATE/DELETE)
            # - Query references the correct table name
            # - Query doesn't contain malicious SQL injection attempts

            # Execute query using pandas for easy result handling
            df_result = pd.read_sql_query(sql_query, conn)

            # TODO: Add your result processing logic here
            # Examples:
            # - Format data types for JSON serialization
            # - Handle large result sets with pagination
            # - Apply post-processing transformations
            # - Add summary statistics

            results = {
                "data": df_result.to_dict("records"),
                "columns": list(df_result.columns),
                "row_count": len(df_result),
            }

            return results

        except Exception as e:
            # TODO: Add better error handling and logging
            raise Exception(f"Error executing SQL query: {str(e)}")
        finally:
            conn.close()

    def get_table_context(self, table_name: str) -> Dict[str, Any]:
        """
        Get table context for RAG (column info, sample data, etc.).
        This provides context to the LLM for better SQL generation.

        Args:
            table_name: Name of the table

        Returns:
            Dict containing table schema and sample data for RAG context

        TODO: Enhance this method to provide better context:
        - Add column data types and constraints
        - Include column statistics (min, max, avg, unique values)
        - Add relationship information if multiple tables
        - Include data quality metrics
        """
        conn = sqlite3.connect(self.db_path)
        try:
            # Get table schema information
            cursor = conn.cursor()
            cursor.execute(f"PRAGMA table_info({table_name})")
            columns_info = cursor.fetchall()

            # Format column information
            columns = []
            for col_info in columns_info:
                columns.append(
                    {
                        "name": col_info[1],
                        "type": col_info[2],
                        "nullable": not col_info[3],
                    }
                )

            # Get sample data (first few rows for context)
            sample_df = pd.read_sql_query(f"SELECT * FROM {table_name} LIMIT 3", conn)
            sample_data = sample_df.to_dict("records")

            # Get row count
            cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
            row_count = cursor.fetchone()[0]

            # TODO: Add more context information here:
            # - Column statistics (DISTINCT values, etc.)
            # - Data patterns and examples
            # - Business context if available

            context = {
                "table_name": table_name,
                "columns": columns,
                "sample_data": sample_data,
                "row_count": row_count,
                "column_names": [col["name"] for col in columns],
            }

            return context

        finally:
            conn.close()

    def list_tables(self) -> List[str]:
        """List all tables in the database"""
        conn = sqlite3.connect(self.db_path)
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
            tables = [row[0] for row in cursor.fetchall()]
            return tables
        finally:
            conn.close()

    def delete_table(self, table_name: str):
        """Delete a table from the database"""
        conn = sqlite3.connect(self.db_path)
        try:
            cursor = conn.cursor()
            cursor.execute(f"DROP TABLE IF EXISTS {table_name}")
            conn.commit()
        finally:
            conn.close()

    def get_table_info(self, table_name: str) -> Dict[str, Any]:
        """
        Get detailed information about a specific table.

        TODO: Expand this method to include:
        - Column statistics and distributions
        - Data quality metrics
        - Index information
        - Table relationships
        """
        return self.get_table_context(table_name)
